# 商业决策平台的智能数据管理系统

何慕婷 23307100075

---

## 一、营销任务优先调度功能

> 该功能维护一个存储所有营销任务的结构。该结构需要有基础的插入、删除、更改营销任务的功能，并支持执行优先级最高的任务、查看优先级最高的前 k 个任务等高级操作。其中，一个任务的优先级定义为其紧急度和影响力的乘积。（拓展：如果这些营销任务之间存在前置依赖，即一个任务必须在另一个任务之后完成，应该如何完善此功能？任务之间的依赖关系使用一个有向图表示。）
> 

### （一）功能设计及实现思路

### **1. 核心数据结构（TaskScheduler）**

- **Task 类**：封装任务属性（名称、紧急度、影响力、优先级）。支持修改属性并自动更新优先级。
- **Dependency 类**：表示任务间的依赖关系，存储起点和终点任务。
- **TaskDependency 类**：**基于邻接表实现有向图**，管理任务及其依赖关系，支持添加、删除任务、依赖等功能。
- **MaxHeap 类**：**最大堆结构**，用于高效维护可执行任务的优先级，支持插入、删除、修改任务等操作，支持执行优先级最高的任务、查看优先级最高的前 k 个任务等高级操作。
- **TaskScheduler 类**：整合图和堆，借助图中的依赖关系信息来同步维护堆中节点。

### **2. 依赖关系管理**

- **有向图表示**：使用**邻接映射**存储依赖，确保依赖关系的快速查询。
- **环路检测**：通过**深度优先搜索（DFS）**方法检查添加依赖时是否形成环路。
- **依赖触发堆更新**：当任务被依赖（图中节点入度不为0）时，从堆中移除；当无依赖（图中节点入度为0）时，重新加入堆。

### **3. 优先级调度**

- **最大堆实现**：支持插入/删除/修改任务的基础功能，通过**堆向上冒泡/堆向下冒泡**维护堆性质。
- **执行优先级最高的任务**：
    - 返回堆顶任务并用堆中最后一个任务代替，通过堆向下冒泡恢复堆性质。
    - 任务完成后，下游任务若依赖数为0，重新加入堆。
- **查看优先级最高的前k个任务**：
    - 使用辅助堆（最大堆），维护所有候选任务。
    - 初始时在辅助堆中加入原最大堆的根节点。
    - 每次取出辅助堆顶任务后，将其在原堆中的左右子节点加入辅助堆，并通过堆向上冒泡恢复堆性质。
    - 直到从辅助堆中取出了k个任务为止。

### （二）重要算法时间与空间复杂度分析

n为总任务数；m为总依赖数；d为单个任务的下游任务数

| **操作** | **时间复杂度** | **空间复杂度** | **说明** |
| --- | --- | --- | --- |
| 添加任务（**`add_new_task`**） | O(log n) | O(1) | 堆插入主导 |
| 修改任务（**`modify_task`**） | O(log n) | O(1) | 堆调整主导 |
| 删除任务（**`remove_task`**） | O(d log n) | O(1) | 下游任务可能触发入堆操作，否则只有出堆操作（O(log n)） |
| 添加依赖（**`add_dependency`**） | O(m+n) | O(1) | 路径检查（DFS）主导，可能涉及出堆操作（O(log n)） |
| 删除依赖（**`remove_dependency`**） | O(log n) | O(1) | 可能触发一个任务的入堆操作 |
| 执行优先级最高的任务（**`do_top_task`**） | O(d log n) | O(1) | 下游任务可能触发入堆操作，否则只有出堆操作（O(log n)） |
| 查看优先级最高的前k个任务（**`top_k_tasks`**） | O(k log k) | O(k) | 每次取出辅助堆顶（O(log k)），添加两个子节点（O(log k)），共k次；辅助堆最多有k个节点 |

---

## 二、客户网络与影响力传播分析

> 该功能基于存储客户之间关系的加权有向图进行分析。请自行设计算法评估每一位客户的重要性，并寻找每一位客户能影响到的所有其他客户。（拓展：当图中两个客户间的路径过长或路径影响力过小时，这两个客户间的影响可以忽略不计。在此基础上，完善这一部分功能。）
> 

### （一）功能设计及实现思路

### **1. 核心数据结构（CustomerNetwork）**

- **Customer 类**：表示客户节点，仅存储客户名称。
- **Relationship 类**：表示加权有向边，存储起点、终点和权重（0~1）。
- **CustomerNetwork类**：基于邻接映射实现加权有向图，管理客户节点和关系。

### **2. 核心功能**

- **客户重要性评估**：
    - 基于传统PageRank算法改进，考虑边权重对影响力传播的作用。
    - 公式迭代更新：
        
        $$
        PR_{\text{new}}(v) = \frac{1-d}{N} + leak + d \cdot \left( \sum_{u \in Out(v)} PR(u) \cdot \frac{w_{v→u}}{S(u)} \right)
        $$
        
        $$
         S(u) = \sum_{v \in In(u)} w_{v→u}
        $$
        
    - 处理出度为0的节点的”泄漏“问题，确保数值稳定性。
- **客户影响力传播分析**：
    - **基础DFS**：通过深度优先遍历，找到每个客户能直接影响或间接影响的所有客户。
    - **带剪枝的DFS**：
        - 路径影响力计算为路径上所有边权重的乘积。
        - 限制路径层数和路径影响力，动态剪枝不满足条件的路径。
        - 在搜索时缓存中间结果，避免重复计算。

### （二）重要算法时间与空间复杂度分析

V为顾客数（节点数）；E为关系数（边数）

### **1. PageRank算法（`page_rank`）**

- **时间复杂度**：
    - 每次迭代需遍历所有节点和边：
        - 计算出边权重总和：O(V+E)。
        - 更新PageRank值：O(V+E)。
        - 总复杂度：O(max_iter×(V+E))。假设 **`max_iter=100`**，则为 O(100(V+E))→O(V+E)。
- **空间复杂度**：
    - 存储 **`out_weights`**、**`pr`**、**`new_pr`**：O(V)。
    - 总复杂度：O(V)。

### **2. 基础DFS（`reachable_customers`）**

- **时间复杂度**：
    - 每个节点遍历一次，每条边访问一次。
    - 总复杂度：O(V×(V+E))。（每个节点启动一次DFS，最坏情况下全图遍历）
- **空间复杂度**：
    - 递归栈深度最坏为 O(V)。
    - 存储结果 **`result`**：O(V^2)。

### **3. 带剪枝的DFS（`reachable_customers_pruned`）**

- **时间复杂度**：
    - 剪枝减少遍历的分支，但最坏情况下仍为 O(V×(V+E))。
    - 实际复杂度取决于 **`max_depth`** 和 **`min_influence`**。例如，**`max_depth=3`** 时，复杂度为 O(V×3^k)，其中k为平均出边数。
- **空间复杂度**：
    - 同基础DFS，但剪枝减少递归深度，实际空间更低。

---

## 三、商品数据检索

> 该功能维护一个管理所有商品的结构。该结构需要有基础的插入、删除、更改商品信息的功能，并支持寻找任意价格范围内的所有商品的操作。请实现该结构。
实际上，由于该平台上的商品数目过多，所有的商品数据存储在磁盘上，且无法被全部读取到内存后进行处理。这时，普通的二叉搜索树性能无法令人满意。请自行决定使用何种数据结构存储大量的商品数据，并实现该数据结构。要求该数据结构同样支持高效的插入、删除、更改、搜索等功能。
> 

### （一）功能设计及实现思路

### **1. 核心数据结构（CommoditySearcher）**

- **Commodity 类**：封装商品属性（名称、价格、热度），支持动态修改。
- **CommoditySearcher 类**：基于 **B+树** 实现，用于高效管理商品数据。
    
    **B+树的选择**：
    
    - **适合大规模数据**：树高远低于二叉搜索树，减少磁盘访问次数。
    - **范围查询高效**：叶子节点链表直接支持顺序遍历，无需回溯父节点。
    - **插入/删除高效**：通过分裂/合并操作保持平衡，避免退化为链表。

### **2. 核心功能**

- **插入商品**：
    - 递归向下查找插入位置，若节点已满则分裂。（先分裂，再下钻）
    - 分裂操作维护叶子节点的链表连接，确保范围查询的连续性。
- **删除商品**：
    - 定位到商品后删除键值，处理节点下溢。
        - 优先向左右兄弟借键，避免合并导致的树结构调整。
        - 若兄弟节点无法借键，则合并节点并递归处理父节点。
    - 递归调整父节点。若根节点变为空，此时将子节点提升为新根。
- **范围查询**：
    - 利用叶子节点的链表特性，从下限开始遍历，直到超出上限。
- **更改商品信息**：
    - 若价格未变，直接修改节点内的商品信息。
    - 若价格变化，先删除旧记录再插入新记录，确保B+树的有序性。

### （二）重要算法时间与空间复杂度分析

m为B+树的阶数；N为商品数；

### 时间复杂度

### **1. 插入操作（`insert`）**

- 查找插入位置：**O(logₘ N)** （树的高度）。
- 节点分裂：每次分裂操作的时间为 **O(1)**，但最多需要处理 **O(logₘ N)** 层。
- **总复杂度**：**O(logₘ N)** 。

### **2. 删除操作（`delete`）**

- 定位节点：**O(logₘ N)** 。
- 处理下溢（借键/合并）：最多递归调整至根节点，每次调整时间为 **O(1)**。
- **总复杂度**：**O(logₘ N)** 。

### **3. 范围查询（`search_range`）**

- 定位到起始叶子节点：**O(logₘ N)** 。
- 遍历链表直到超出上限：**O(k)**（k为结果数量）。
- **总复杂度**：**O(logₘ N+k)** 。

### **4. 修改操作（`modify`）**

- 若价格不变：**O(logₘ N)** （查找节点）。
- 若价格变化：等同于一次删除 + 一次插入，即 **O(logₘ N)**  。

### 空间复杂度

1. **叶子节点**：
    - 所有数据均存储在叶子节点中，每个叶子节点最多包含 **m-1** 个键值（数据项）。
    - 叶子节点总数至少为 **⌈N/(m-1)⌉**，因此叶子层的总空间为 **O(N)**。
2. **内部节点**：
    - 内部节点仅存储键和子节点指针，不存储实际数据。
    - 内部节点总数约为 **O(N/m)**（因为树的高度为 **O(logₘ N)**，每层节点数按指数级减少）。
    - 每个内部节点占用 **O(m)** 空间，因此内部节点的总空间为 **O(N)**（但常数因子远小于叶子节点）。
3. **总空间**：
    - 叶子节点和内部节点的空间总和为 **O(N) + O(N) = O(N)**。

---
